---

name: Цепочка вызовов
theory: |

  Попробуйте ответить на вопрос, заработает ли следующий код — и если да, то что он напечатает на экран?

  ```python
  name = 'Tirion'
  print(name.upper().lower()) # => ?
  ```

  Если ваш ответ `tirion`, то вы ухватили идею)

  Синтаксис нескольких подряд идущих точек мы видим впервые, но все операции, которые здесь встречаются, нам знакомы. Всё, что произошло в этом коде — это объединение уже известных возможностей языка. Такое в программировании происходит довольно часто. Даже не зная синтаксиса, можно пробовать комбинировать различные подходы, и есть неплохая вероятность, что они заработают.

  Самый простой способ понять как работает этот код — разбить цепочку на отдельные операции:

  ```python
  name = 'Tirion'
  upper_name = name.upper() # 'TIRION'
  print(upper_name.lower()) # 'tirion'
  ```

  Эти примеры абсолютно эквивалентны. Мы можем выполнять операции последовательно с промежуточным созданием переменных, а можем строить непрерывную цепочку из атрибутов и методов. В цепочках вычисления всегда идут слева направо.

  Ещё один пример для закрепления:

  ```python
  name = 'Tirion';
  print(name.replace('Ti', 'Ki').lower()) # => ?
  ```

  Подобный код требует небольших умственных усилий. Важно понимать, что `.lower()` применяется к результату вызова метода, который находится левее. А метод `replace()` возвращает строку. Иначе говоря, метод `lower()` вызывается на строке, которую возвращает метод `replace()`. Новички часто делают ошибки в цепочках с методами, забывая ставить вызов:

  ```python
  name = 'Tirion';
  // Этот код отработает неверно!
  print(name.upper.lower());
  ```

  Продолжая эту идею, возможно строить бесконечно длинные (хотя, в данном случае, бесполезные) цепочки, которые, включают в себя даже слайсы:

  ```python
  # Чему равен результат такого вызова?
  print(name[1:5].upper().find('I'))
  ```

  *С функциями подобный трюк не сработает, так как при обычном использовании они вкладываются друг в друга f(f(f())), что значительно ухудшает анализ. Но это не значит, что нельзя сделать красиво — можно и даже нужно. В других языках это реализуется через композицию функций или пайплайн-оператор*

instructions: |

  С помощью слайсов, получите часть предложения, записанного в переменную `text`, c `5` по `15` символы включительно. Полученную подстроку обработайте методом `.strip()` и выведите на экран длину итоговой подстроки. Выполните эти операции подряд в цепочке без создания промежуточных переменных.

tips: []

