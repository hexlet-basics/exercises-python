---

name: Результат логических выражений
theory: |

  Посмотрите на код ниже и попробуйте угадать, что будет напечатано на экран?

  ```python
  print(0 or 1)
  ```

  Правильный ответ:

  <pre class='hexlet-basics-output'>
    1
  </pre>

  Оператор **ИЛИ** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в `True`, если такого аргумента нет, возвращается последний (правый).

  Пример:

  ```python
  print(0 and 1)
  ```

  <pre class='hexlet-basics-output'>
    0
  </pre>

  Оператор **И** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в `False`, если такого аргумента нет, возвращается последний (правый).

  В Python есть два простых правила, по которым происходят преобразования:

  * `0`, `0.0`, `''`, `None`, приводятся к `False`. Эти значения называют *falsy*. Сюда входят еще некоторые другие типы данных, которые мы пока не проходили, но будем изучать на Хекслете.
  * Всё остальное приводится к `True`

  Этим активно пользуются в разработке, например, для определения значения по умолчанию:

  ```python
  value = name or ''
  # Примеры
  234 or '' # 234
  'hexlet' or '' # 'hexlet'
  None or '' # ''
  ```
  Если `name` примет одно из falsy значений, переменной `value` будет присвоена пустая строка. В этом случае в последующем коде мы сможем работать с `value` как со строкой.

  Но здесь есть потенциальный баг. Если `name` содержит falsy значение, а присваивание переменной value значений типа `0`, `False`, `None`, допустимо, то код выше начнет работать неверно:

  ```python
  # Упс. Значение на самом деле есть,
  # но оно является Falsy, поэтому не выбирается на условии OR
  False or '' # ''
  0 or '' # ''
  None or '' # ''
  ```

  ## Составные выражения

  Соединяя логические выражения между собой, мы можем получать довольно интересные способы решения задач с кодом. Допустим нам нужно реализовать код, в котором в переменную записывается строка `yes` если число четное, либо `no` если не четное. Как это сделать используя знания полученные выше?

  ```python
  # число четное
  result = 10 % 2 == 0 and 'yes' or 'no' # 'yes'

  # или сразу печатаем на экран
  print(10 % 2 == 0 and 'yes' or 'no') # => 'yes'

  # число нечетное
  print(11 % 2 == 0 and 'yes' or 'no') # => 'no'
  ```

  Как работают эти выражения? В соответствии с порядком и приоритетом. Приоритет присваивания самый низкий, поэтому оно происходит в конце. Приоритет сравнения `==` выше чем приоритет логических операторов `and` и `or`, поэтому сравнение происходит раньше. Дальше код выполняется слева направо так как приоритет `and` и `or` совпадает. По шагам:

  ```python
  # Для четного
  # 1 шаг
  10 % 2 == 0 # True
  # 2 шаг
  True and 'yes' # результат истина
  # проверка на or выполняется, но правая часть не исполняется, так как сразу возвращается 'yes'

  # Для нечетного
  # 1 шаг
  11 % 2 == 0 # False
  # 2 шаг
  False and 'yes' # результат ложь, проверяем дальше
  # 3 шаг
  False or 'no' # выбирается и возвращается 'no'
  ```

  Точно такую же схему можно использовать с любым выражением в начале

  ```python
  print(somefunc() and 'yes' or 'no')
  ```

  ## Двойное отрицание

  Вспомните операцию отрицания:

  ```python
  answer = True
  print(not answer) # => False
  ```

  При двойном отрицании итоговое значение равно начальному:

  ```python
  answer = True
  print(not not answer) # => True
  ```

  Но здесь дополнительно происходят преобразования типа. Поэтому результатом двойного отрицания всегда будет значение типа _boolean_.

  ## Ошибка выбора

  Представьте себе задачу, в которой нам нужно проверить, что значение равно либо одному, либо другому. Например переменная `value` должна содержать одно из двух значений: `first` или `second`. Начинающие разработчики иногда записывают это выражение так:

  ```python
  value == ('first' or 'second')
  ```

  В голове мы это себе примерно так и представляем, но языки работают по другому, поэтому такой код приведет к неверному результату. Как его правильно прочитать? Мы должны вспомнить приоритет выполнения операций. Первым делом вычисляется все что указано в скобках, то есть `'first' or 'second'`. Если выполнить этот код в репле, то вывод будет таким:

  ```bash
  python
  Python 3.8.2 (default, Apr 12 2020, 15:53:37)
  >>> 'first' or 'second'
  'first'
  >>>
  ```

  Теперь мы можем заменить исходное выражение, на частично вычисленное:

  ```python
  value == 'first'
  ```

  Совсем не то, что мы ожидали. А теперь вернемся к началу, и напишем проверку правильно:

  ```python
  # Скобки ставить не обязательно,
  # потому что приоритет == выше чем приоритет or
  value == 'first' or value == 'second'
  ```

instructions: |

  Реализуйте функцию `string_or_not()`, которая проверяет является ли переданный параметр строкой. Если да, то возвращается `'yes'` иначе `'no'`

  ```python
  string_or_not('Hexlet') # 'yes'
  string_or_not(10) # 'no'
  string_or_not('') # 'yes'
  string_or_not(False) # 'no'
  ```

  Проверить что значение это строка можно с помощью функции [isinstance()](https://docs.python.org/3/library/functions.html#isinstance):

  ```python
  isinstance(3, str) # False
  isinstance('Hexlet', str) # True
  ```

# tips:
#   - |
#     [Boolean](https://ru.wikipedia.org/wiki/Логический_тип)
#   - |
#     [Извлечение символов из строки](https://ru.code-basics.com/languages/javascript/lessons/symbols)
