---

name: Результат логических выражений
theory: |

  Посмотрите на код ниже и попробуйте угадать, что будет напечатано на экран?

  ```python
  print(0 or 1)
  ```

  Правильный ответ:

  <pre class='hexlet-basics-output'>
    1
  </pre>

  Оператор **ИЛИ** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в `True`.

  Пример:

  ```python
  print(0 and 1)
  ```

  <pre class='hexlet-basics-output'>
    0
  </pre>

  Оператор **И** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в `False`.

  В Python есть два простых правила, по которым происходят преобразования:

  * `0`, `0.0`, `''`, `None`, приводятся к `False`. Эти значения называют *falsy*. Сюда входят еще некоторые другие типы данных, которые мы пока не проходили, но будем изучать на Хекслете.
  * Всё остальное приводится к `True`

  Этим активно пользуются в разработке, например, для определения значения по умолчанию:

  ```python
  value = name or ''
  # Примеры
  234 or '' # 234
  'hexlet' or '' # 'hexlet'
  None or '' # ''
  ```
  Если `name` примет одно из falsy значений, переменной `value` будет присвоена пустая строка. В этом случае в последующем коде мы сможем работать с `value` как со строкой.

  Но здесь есть потенциальный баг. Если `name` содержит falsy значение, а присваивание переменной value значений типа `0`, `False`, `None`, допустимо, то код выше начнет работать неверно:

  ```python
  # Упс. Значение на самом деле есть,
  # но оно является Falsy, поэтому не выбирается на условии OR
  False or '' # ''
  0 or '' # ''
  None or '' # ''
  ```

  Вспомните операцию отрицания:

  ```python
  answer = True
  print(not answer) # => False
  ```

  При двойном отрицании итоговое значение равно начальному:

  ```python
  answer = True
  print(not not answer) # => True
  ```

  Но здесь дополнительно происходят преобразования типа. Поэтому результатом двойного отрицания всегда будет значение типа _boolean_.

  ## Ошибка выбора

  Представьте себе задачу, в которой нам нужно проверить, что значение равно либо одному, либо другому. Например переменная `value` должна содержать одно из двух значений: `first` или `second`. Начинающие разработчики иногда записывают это выражение так:

  ```python
  value == ('first' or 'second')
  ```

  В голове мы это себе примерно так и представляем, но языки работают по другому, поэтому такой код приведет к неверному результату. Как его правильно прочитать? Мы должны вспомнить приоритет выполнения операций. Первым делом вычисляется все что указано в скобках, то есть `'first' or 'second'`. Если выполнить этот код в репле, то вывод будет таким:

  ```bash
  python
  Python 3.8.2 (default, Apr 12 2020, 15:53:37)
  >>> 'first' or 'second'
  'first'
  >>>
  ```

  Теперь мы можем заменить исходное выражение, на частично вычисленное:

  ```python
  value == 'first'
  ```

  Совсем не то, что мы ожидали. А теперь вернемся к началу, и напишем проверку правильно:

  ```python
  # Скобки ставить не обязательно,
  # потому что приоритет == выше чем приоритет or
  value == 'first' or value == 'second'
  ```

instructions: |

  Реализуйте функцию `string_or_not()`, которая проверяет является ли переданный параметр строкой. Если да, то возвращается `'yes'` иначе `'no'`

  ```python
  string_or_not('Hexlet') # 'yes'
  string_or_not(10) # 'no'
  string_or_not('') # 'yes'
  string_or_not(False) # 'no'
  ```

  Проверить что значение это строка можно с помощью функции [isinstance()](https://docs.python.org/3/library/functions.html#isinstance):

  ```python
  isinstance(3, str) # False
  isinstance('Hexlet', str) # True
  ```

# tips:
#   - |
#     [Boolean](https://ru.wikipedia.org/wiki/Логический_тип)
#   - |
#     [Извлечение символов из строки](https://ru.code-basics.com/languages/javascript/lessons/symbols)

