---

name: Условия внутри тела цикла
theory: |

  Тело цикла, как и тело функции — это место выполнения инструкций. Значит, мы можем использовать внутри него всё изученное ранее, например — условные конструкции.

  Представьте себе функцию, которая считает, сколько раз входит буква в предложение. Пример её работы:

  ```python
  count_chars('Fear cuts deeper than swords.', 'e')  # 4
  # Если вы ничего не нашли, то результат — 0 совпадений
  count_chars('Sansa', 'y')  # 0
  ```

  Перед тем как посмотреть её содержимое, попробуйте ответить на вопросы:

  * Является ли эта операция агрегацией?
  * Какой будет проверка на вхождение символа?

  ```python
  def count_chars(string, char):
      index = 0
      count = 0
      while index < len(string):
          if string[index] == char:
              # Считаем только подходящие символы
              count = count + 1
          # Счётчик увеличивается в любом случае
          index = index + 1
      return count
  ```

  Эта задача является агрегирующей. Несмотря на то, что она считает не все символы, для подсчёта самой суммы все равно приходится анализировать каждый символ.

  Ключевое отличие этого цикла от рассмотренных ранее - это наличие условия внутри тела. Переменная `count` увеличивается только в том случае, когда текущий рассматриваемый символ совпадает с ожидаемым.

  В остальном — это типичная агрегатная функция, которая возвращает количество нужных символов вызываемому коду.

instructions: |

  Функция из теории учитывает регистр букв. То есть `A` и `a` с её точки зрения разные символы. Реализуйте вариант этой же функции, так чтобы регистр букв был не важен:

  ```python
  count_chars('HexlEt', 'e')  # 2
  count_chars('HexlEt', 'E')  # 2
  ```

tips: []
