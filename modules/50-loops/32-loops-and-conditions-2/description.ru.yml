---

name: Циклы и условия 2
theory: |

  #### Пример 2: Условие внутри цикла

  Задача: написать функцию `get_even_numbers_up_to()`, которая принимает число и возвращает в виде строки все чётные числа от 1 до этого числа включительно.

  Начнём писать функцию:

  ```python
  def get_even_numbers_up_to(number):
  ```

  Нам нужен цикл для сбора чисел от 1 до `number`, но не всех чисел, а только чётных.

  Может показаться, что для этого нужен какой-то особый цикл, ведь нам нужны не ВСЕ числа, а только некоторые. И тут возможны разные подходы, но мы рассмотрим самый очевидный и простой, не требующий никаких новых навыков и знаний.

  Попробуем для начала решить более простую задачу: пусть функция на самом деле возвращает **все** числа от 1 до `number`.

  Делаем всё как обычно — счётчик, цикл, обновление счётчика:

  ```python
  def get_even_numbers_up_to(number):
      counter = 1
      result = ''

      while counter != number:
          result = result + str(counter)
          counter += 1

      return result
  ```

  Счётчик `counter` выполняет сразу две задачи: отслеживает количество повторений и является тем числом, которое нужно вывести на экран.

  Запустим:

  ```python
  print(get_even_numbers_up_to(5))
  ```

  <pre class='hexlet-basics-output'>1234</pre>

  Работает, но не до конца: последнее число не вывелось. Видимо, цикл работает, но останавливается на один шаг раньше, чем нам нужно. Завершение цикла зависит от предиката в `while`, давайте посмотрим на него внимательнее:

  ```python
  while counter != number:
  ```

  *«Пока счётчик не равен `number`»*. Получается, когда счётчик равен `number`, цикл уже не исполняется. Но нам нужно, чтобы он исполнился ещё один раз, когда счётчик равен `number`, а потом уже остановился.

  Предикат нужно изменить на *«пока счётчик меньше или равен `number`»*:

  ```python
  def get_even_numbers_up_to(number):
      counter = 1
      result = ''

      while counter <= number:
          result = result + str(counter)
          counter += 1

      return result
  ```

  Запустим:

  ```python
  print(get_even_numbers_up_to(5))
  ```

  <pre class='hexlet-basics-output'>12345</pre>

  Ура!

  Теперь вернёмся к начальной задаче: возвращать нужно только чётные числа. Иными словами, если число чётное — то добавлять его в результат, в ином случае — ничего не делать.

  Значит, нужно условие с `if` прямо в теле цикла. В том месте, где мы делали добавление числа в строку-результат, нужно добавить условие:

  ```python
  def get_even_numbers_up_to(number):
      counter = 1
      result = ''

      while counter <= number:
          if counter % 2 == 0:
              result = result + str(counter)

          counter += 1

      return result
  ```

  Запустим:

  ```python
  print(get_even_numbers_up_to(5))
  ```

  <pre class='hexlet-basics-output'>24</pre>

  ```python
  print(get_even_numbers_up_to(9))
  ```

  <pre class='hexlet-basics-output'>2468</pre>

  Работает!

  Несмотря на то, что циклом мы проходим по **всем** числам от 1 до `number`, благодаря условию добавление в строку-результат происходит только для чётных. Счётчик же увеличивается в любом случае на каждом шагу.

instructions: |

  Как видите, функция `get_even_numbers_up_to()` возвращает числа, слепив их вместе. Модифицируйте функцию так, чтобы числа в результате стояли через запятую:

  <pre class='hexlet-basics-output'>2,4,6,8,</pre>

  #### Задание со звёздочкой

  Попробуйте самостоятельно на [https://repl.it/](https://repl.it/languages/python3) реализовать такое решение, чтобы после последнего числа не было запятой, но была точка:

  ```python
  print(get_even_numbers_up_to(9))
  ```

  <pre class='hexlet-basics-output'>2,4,6,8.</pre>

tips: []
